package de.qaware.dumpimporter.steps.pide

import scala.language.implicitConversions
import scala.util.parsing.combinator.Parsers
import scala.util.parsing.input.{NoPosition, Position, Reader}

import com.typesafe.scalalogging.Logger
import de.qaware.common.solr.dt.DocumentationType
import de.qaware.dumpimporter.dataaccess.treequery.QueryDsl.{all, ofOne, single}
import de.qaware.dumpimporter.dataaccess.treequery.YxmlTreeQuery.{YxmlNode, body, key, keyValue, tag}
import de.qaware.dumpimporter.dataaccess.treequery.{QueryDsl, QueryError, QueryNode}
// scalastyle:off UnderscoreImportChecker
import de.qaware.dumpimporter.steps.pide.PideField._
// scalastyle:on UnderscoreImportChecker
import de.qaware.yxml.Yxml

/** Trait for simple errors. */
trait PideParseError extends Throwable {

  /** Error message.
    *
    * @return error message
    */
  def msg: String
}

/** Error while lexing strings.
  *
  * @param msg error message
  */
final case class PideLexError(override val msg: String) extends PideParseError

/** Reader for ymxl nodes.
  *
  * @param nodes to read from
  */
class YxmlNodeReader(nodes: List[YxmlNode]) extends Reader[YxmlNode] {
  @SuppressWarnings(Array("TraversableHead")) // Justification: External reader interface is unsafe
  override def first: YxmlNode = nodes.head
  override def rest: Reader[YxmlNode] = new YxmlNodeReader(nodes.tail)
  override def pos: Position = NoPosition
  override def atEnd: Boolean = nodes.isEmpty
}

/** Lexes YXML subtrees into flat tokens. */
object PideLexer extends Parsers {
  override type Elem = YxmlNode

  private val logger = Logger[PideLexer.type]

  // Helper methods

  private def nodeMatches(query: QueryNode[YxmlNode, Either[QueryError, YxmlNode]]) = Parser { input =>
    if (input.atEnd)
      Failure("Empty input", input)
    else
      query.in(input.first) match {
        case Right(e) => Success(e, input.rest)
        case Left(error) =>
          logger.whenDebugEnabled { logger.debug(s"Could not find node: $error") }
          Failure("Required exactly one match", input)
      }
  }

  private def extractBody(node: YxmlNode) = {
    // XML_BODY tags are generated by isabelle and do not belong to the original source text
    (all thats body without (tag(XmlBody) or tag(Delete)) in node).map(_.getBody).mkString(" ")
  }

  private def delimiterQuery(delim: PideField.Value): QueryNode[YxmlNode, Either[QueryError, YxmlNode]] = {
    single root ofOne thats tag(Delimiter) parent ofOne thats tag(NoCompletion) parent ofOne thats body(delim.toString)
  }

  private def keywordQuery(keyword: PideField.Value): QueryNode[YxmlNode, Either[QueryError, YxmlNode]] = {
    single root ofOne thats (tag(Keyword2) and keyValue(Kind, Keyword.toString)) parent ofOne thats body(
      keyword.toString)
  }

  // Parsing rules
  // scalastyle:off scaladoc
  /** Parses '::' pide token. */
  protected def typeDelimiter: Parser[TypeDelimToken.type] =
    nodeMatches(delimiterQuery(TypeDelimiter)) ^^ (_ => TypeDelimToken)

  /** Parses '|' pide token. */
  protected def defDelimiter: Parser[DefDelimToken.type] =
    nodeMatches(delimiterQuery(DefDelimiter)) ^^ (_ => DefDelimToken)

  /** Parses ':' pide token. */
  protected def nameDelimiter: Parser[NameDelimToken.type] =
    nodeMatches(delimiterQuery(NameDelimiter)) ^^ (_ => NameDelimToken)

  /** Parses 'where' pide keyword. */
  protected def whereKeyword: Parser[WhereToken.type] = {
    nodeMatches(keywordQuery(Where)) ^^ (_ => WhereToken)
  }

  /** Parses 'for' pide keyword. */
  protected def forKeyword: Parser[ForToken.type] = {
    nodeMatches(keywordQuery(For)) ^^ (_ => ForToken)
  }

  /** Parses pide string token with inner syntax content. */
  protected def string: Parser[StringToken] =
    nodeMatches(single root ofOne thats tag(String)) ^^ (x => new StringToken(extractBody(x)))

  /** Parses whitespace pide token. */
  protected def ws: Parser[WhitespaceToken] =
    nodeMatches(single root ofOne thats body("\\s+".r)) ^^ (x => new WhitespaceToken(x.getBody))

  /** Parses pide entity def token. */
  protected def entityDef: Parser[DefToken] = {
    // Entity defs are structured as follows: <Global ref ><Local ref/></Global ref>
    nodeMatches(single root ofOne thats (tag(Entity) and key(Def)) parent ofOne thats (tag(Entity) and key(Def))) ^^ {
      parent =>
        single thats (tag(Entity) and key(Def)) parent ofOne thats body() in parent match {
          case Left(error) =>
            logger.error(s"Could not find local definition: $error")
            throw new IllegalStateException("Could not extract entity")
          case Right(elem) => DefToken(extractBody(parent), elem.getValue(Def).toLong)
        }
    }
  }

  /** Pares pide comment token. */
  protected def comment: Parser[CommentToken] = nodeMatches(single root ofOne thats tag(Comment)) ^^ { commentTree =>
    (single thats tag(Cartouche) in commentTree) match {
      case Left(_) => CommentToken(extractBody(commentTree), DocumentationType.Meta)
      case Right(_) => CommentToken(extractBody(commentTree), DocumentationType.Inline)
    }
  }

  /** Parses any yxml subtree. */
  protected def any: Parser[UnknownToken] = Parser { input =>
    if (input.atEnd) {
      Failure("Empty input", input)
    } else {
      Success(new UnknownToken(extractBody(input.first)), input.rest)
    }
  }
  // scalastyle:on scaladoc

  /** Parses all types of tokens.
    *
    * @return token list
    */
  def tokens: Parser[List[PideToken]] =
    phrase(rep((typeDelimiter | defDelimiter | nameDelimiter | whereKeyword | string | ws | entityDef | comment) | any))

  /** Applies parser on given yxml.
    *
    * @param yxml yxml tree to parse
    * @return parsed token list or error if parsing failed
    */
  def apply(yxml: Yxml): Either[PideLexError, List[PideToken]] = {
    val yxmlNodes = yxml.elems.map(new YxmlNode(_))

    // Get relevant subtrees
    val topLevelNodes = all first ofOne thats QueryDsl.not(
      tag(Accepted) or tag(Running) or tag(Finished) or tag(Timing)) in yxmlNodes

    val reader = new YxmlNodeReader(topLevelNodes.toList)

    tokens(reader) match {
      case NoSuccess(msg, _) => Left(PideLexError(msg))
      case Success(result, _) => Right(result)
    }
  }
}
